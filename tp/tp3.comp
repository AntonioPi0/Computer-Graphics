#version 430 core

layout(binding = 2, rgba32f) uniform image2D framebuffer;
layout(binding = 3, rgba32f) uniform image2D momentsBuffer;

uniform sampler2D colorTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform bool blinnPhong;
uniform bool transparent;
uniform float shininess;
uniform float eta;
uniform float radius;
uniform float groundDistance;
uniform vec3 center;
uniform bool useHaltonSequence;
uniform uint frameIndex;

#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001

#define MIN_DISTANCE EPS
#define GROUND_VPTR -1

#define M_1_PI 0.31830988618

#define Ka 0.05
#define Kd 0.3

#define SHADOW_BIAS        0.0005
#define REFLECTION_BIAS    0.0005

const vec3 LUMA_WEIGHTS = vec3(0.2126, 0.7152, 0.0722);
const float CONVERGENCE_RATIO = 0.1;
const float MIN_STD_THRESHOLD = 0.01;
const float MIN_SAMPLE_COUNT = 4.0;

const uint HALTON_SIZE = 256u;
const uint HALTON_MASK = HALTON_SIZE - 1u;

// Gold Noise ©2015 dcerisano@standard3d.com
// - based on the Golden Ratio
// - uniform normalized distribution
// - fastest static noise generator function (also runs at low precision)
// - use with indicated fractional seeding method.
float PHI = 1.61803398874989484820459;

// Φ = Golden Ratio

float gold_noise(in vec2 xy, in float seed){
return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

const vec2 HALTON_SEQUENCE[256] = vec2[](
    vec2(0.5000000000, 0.3333333333),
    vec2(0.2500000000, 0.6666666667),
    vec2(0.7500000000, 0.1111111111),
    vec2(0.1250000000, 0.4444444444),
    vec2(0.6250000000, 0.7777777778),
    vec2(0.3750000000, 0.2222222222),
    vec2(0.8750000000, 0.5555555556),
    vec2(0.0625000000, 0.8888888889),
    vec2(0.5625000000, 0.0370370370),
    vec2(0.3125000000, 0.3703703704),
    vec2(0.8125000000, 0.7037037037),
    vec2(0.1875000000, 0.1481481481),
    vec2(0.6875000000, 0.4814814815),
    vec2(0.4375000000, 0.8148148148),
    vec2(0.9375000000, 0.2592592593),
    vec2(0.0312500000, 0.5925925926),
    vec2(0.5312500000, 0.9259259259),
    vec2(0.2812500000, 0.0740740741),
    vec2(0.7812500000, 0.4074074074),
    vec2(0.1562500000, 0.7407407407),
    vec2(0.6562500000, 0.1851851852),
    vec2(0.4062500000, 0.5185185185),
    vec2(0.9062500000, 0.8518518519),
    vec2(0.0937500000, 0.2962962963),
    vec2(0.5937500000, 0.6296296296),
    vec2(0.3437500000, 0.9629629630),
    vec2(0.8437500000, 0.0123456790),
    vec2(0.2187500000, 0.3456790123),
    vec2(0.7187500000, 0.6790123457),
    vec2(0.4687500000, 0.1234567901),
    vec2(0.9687500000, 0.4567901235),
    vec2(0.0156250000, 0.7901234568),
    vec2(0.5156250000, 0.2345679012),
    vec2(0.2656250000, 0.5679012346),
    vec2(0.7656250000, 0.9012345679),
    vec2(0.1406250000, 0.0493827160),
    vec2(0.6406250000, 0.3827160494),
    vec2(0.3906250000, 0.7160493827),
    vec2(0.8906250000, 0.1604938272),
    vec2(0.0781250000, 0.4938271605),
    vec2(0.5781250000, 0.8271604938),
    vec2(0.3281250000, 0.2716049383),
    vec2(0.8281250000, 0.6049382716),
    vec2(0.2031250000, 0.9382716049),
    vec2(0.7031250000, 0.0864197531),
    vec2(0.4531250000, 0.4197530864),
    vec2(0.9531250000, 0.7530864198),
    vec2(0.0468750000, 0.1975308642),
    vec2(0.5468750000, 0.5308641975),
    vec2(0.2968750000, 0.8641975309),
    vec2(0.7968750000, 0.3086419753),
    vec2(0.1718750000, 0.6419753086),
    vec2(0.6718750000, 0.9753086420),
    vec2(0.4218750000, 0.0246913580),
    vec2(0.9218750000, 0.3580246914),
    vec2(0.1093750000, 0.6913580247),
    vec2(0.6093750000, 0.1358024691),
    vec2(0.3593750000, 0.4691358025),
    vec2(0.8593750000, 0.8024691358),
    vec2(0.2343750000, 0.2469135802),
    vec2(0.7343750000, 0.5802469136),
    vec2(0.4843750000, 0.9135802469),
    vec2(0.9843750000, 0.0617283951),
    vec2(0.0078125000, 0.3950617284),
    vec2(0.5078125000, 0.7283950617),
    vec2(0.2578125000, 0.1728395062),
    vec2(0.7578125000, 0.5061728395),
    vec2(0.1328125000, 0.8395061728),
    vec2(0.6328125000, 0.2839506173),
    vec2(0.3828125000, 0.6172839506),
    vec2(0.8828125000, 0.9506172840),
    vec2(0.0703125000, 0.0987654321),
    vec2(0.5703125000, 0.4320987654),
    vec2(0.3203125000, 0.7654320988),
    vec2(0.8203125000, 0.2098765432),
    vec2(0.1953125000, 0.5432098765),
    vec2(0.6953125000, 0.8765432099),
    vec2(0.4453125000, 0.3209876543),
    vec2(0.9453125000, 0.6543209877),
    vec2(0.0390625000, 0.9876543210),
    vec2(0.5390625000, 0.0041152263),
    vec2(0.2890625000, 0.3374485597),
    vec2(0.7890625000, 0.6707818930),
    vec2(0.1640625000, 0.1152263374),
    vec2(0.6640625000, 0.4485596708),
    vec2(0.4140625000, 0.7818930041),
    vec2(0.9140625000, 0.2263374486),
    vec2(0.1015625000, 0.5596707819),
    vec2(0.6015625000, 0.8930041152),
    vec2(0.3515625000, 0.0411522634),
    vec2(0.8515625000, 0.3744855967),
    vec2(0.2265625000, 0.7078189300),
    vec2(0.7265625000, 0.1522633745),
    vec2(0.4765625000, 0.4855967078),
    vec2(0.9765625000, 0.8189300412),
    vec2(0.0234375000, 0.2633744856),
    vec2(0.5234375000, 0.5967078189),
    vec2(0.2734375000, 0.9300411523),
    vec2(0.7734375000, 0.0781893004),
    vec2(0.1484375000, 0.4115226337),
    vec2(0.6484375000, 0.7448559671),
    vec2(0.3984375000, 0.1893004115),
    vec2(0.8984375000, 0.5226337449),
    vec2(0.0859375000, 0.8559670782),
    vec2(0.5859375000, 0.3004115226),
    vec2(0.3359375000, 0.6337448560),
    vec2(0.8359375000, 0.9670781893),
    vec2(0.2109375000, 0.0164609053),
    vec2(0.7109375000, 0.3497942387),
    vec2(0.4609375000, 0.6831275720),
    vec2(0.9609375000, 0.1275720165),
    vec2(0.0546875000, 0.4609053498),
    vec2(0.5546875000, 0.7942386831),
    vec2(0.3046875000, 0.2386831276),
    vec2(0.8046875000, 0.5720164609),
    vec2(0.1796875000, 0.9053497942),
    vec2(0.6796875000, 0.0534979424),
    vec2(0.4296875000, 0.3868312757),
    vec2(0.9296875000, 0.7201646091),
    vec2(0.1171875000, 0.1646090535),
    vec2(0.6171875000, 0.4979423868),
    vec2(0.3671875000, 0.8312757202),
    vec2(0.8671875000, 0.2757201646),
    vec2(0.2421875000, 0.6090534979),
    vec2(0.7421875000, 0.9423868313),
    vec2(0.4921875000, 0.0905349794),
    vec2(0.9921875000, 0.4238683128),
    vec2(0.0039062500, 0.7572016461),
    vec2(0.5039062500, 0.2016460905),
    vec2(0.2539062500, 0.5349794239),
    vec2(0.7539062500, 0.8683127572),
    vec2(0.1289062500, 0.3127572016),
    vec2(0.6289062500, 0.6460905350),
    vec2(0.3789062500, 0.9794238683),
    vec2(0.8789062500, 0.0288065844),
    vec2(0.0664062500, 0.3621399177),
    vec2(0.5664062500, 0.6954732510),
    vec2(0.3164062500, 0.1399176955),
    vec2(0.8164062500, 0.4732510288),
    vec2(0.1914062500, 0.8065843621),
    vec2(0.6914062500, 0.2510288066),
    vec2(0.4414062500, 0.5843621399),
    vec2(0.9414062500, 0.9176954733),
    vec2(0.0351562500, 0.0658436214),
    vec2(0.5351562500, 0.3991769547),
    vec2(0.2851562500, 0.7325102881),
    vec2(0.7851562500, 0.1769547325),
    vec2(0.1601562500, 0.5102880658),
    vec2(0.6601562500, 0.8436213992),
    vec2(0.4101562500, 0.2880658436),
    vec2(0.9101562500, 0.6213991770),
    vec2(0.0976562500, 0.9547325103),
    vec2(0.5976562500, 0.1028806584),
    vec2(0.3476562500, 0.4362139918),
    vec2(0.8476562500, 0.7695473251),
    vec2(0.2226562500, 0.2139917695),
    vec2(0.7226562500, 0.5473251029),
    vec2(0.4726562500, 0.8806584362),
    vec2(0.9726562500, 0.3251028807),
    vec2(0.0195312500, 0.6584362140),
    vec2(0.5195312500, 0.9917695473),
    vec2(0.2695312500, 0.0082304527),
    vec2(0.7695312500, 0.3415637860),
    vec2(0.1445312500, 0.6748971193),
    vec2(0.6445312500, 0.1193415638),
    vec2(0.3945312500, 0.4526748971),
    vec2(0.8945312500, 0.7860082305),
    vec2(0.0820312500, 0.2304526749),
    vec2(0.5820312500, 0.5637860082),
    vec2(0.3320312500, 0.8971193416),
    vec2(0.8320312500, 0.0452674897),
    vec2(0.2070312500, 0.3786008230),
    vec2(0.7070312500, 0.7119341564),
    vec2(0.4570312500, 0.1563786008),
    vec2(0.9570312500, 0.4897119342),
    vec2(0.0507812500, 0.8230452675),
    vec2(0.5507812500, 0.2674897119),
    vec2(0.3007812500, 0.6008230453),
    vec2(0.8007812500, 0.9341563786),
    vec2(0.1757812500, 0.0823045267),
    vec2(0.6757812500, 0.4156378601),
    vec2(0.4257812500, 0.7489711934),
    vec2(0.9257812500, 0.1934156379),
    vec2(0.1132812500, 0.5267489712),
    vec2(0.6132812500, 0.8600823045),
    vec2(0.3632812500, 0.3045267490),
    vec2(0.8632812500, 0.6378600823),
    vec2(0.2382812500, 0.9711934156),
    vec2(0.7382812500, 0.0205761317),
    vec2(0.4882812500, 0.3539094650),
    vec2(0.9882812500, 0.6872427984),
    vec2(0.0117187500, 0.1316872428),
    vec2(0.5117187500, 0.4650205761),
    vec2(0.2617187500, 0.7983539095),
    vec2(0.7617187500, 0.2427983539),
    vec2(0.1367187500, 0.5761316872),
    vec2(0.6367187500, 0.9094650206),
    vec2(0.3867187500, 0.0576131687),
    vec2(0.8867187500, 0.3909465021),
    vec2(0.0742187500, 0.7242798354),
    vec2(0.5742187500, 0.1687242798),
    vec2(0.3242187500, 0.5020576132),
    vec2(0.8242187500, 0.8353909465),
    vec2(0.1992187500, 0.2798353909),
    vec2(0.6992187500, 0.6131687243),
    vec2(0.4492187500, 0.9465020576),
    vec2(0.9492187500, 0.0946502058),
    vec2(0.0429687500, 0.4279835391),
    vec2(0.5429687500, 0.7613168724),
    vec2(0.2929687500, 0.2057613169),
    vec2(0.7929687500, 0.5390946502),
    vec2(0.1679687500, 0.8724279835),
    vec2(0.6679687500, 0.3168724280),
    vec2(0.4179687500, 0.6502057613),
    vec2(0.9179687500, 0.9835390947),
    vec2(0.1054687500, 0.0329218107),
    vec2(0.6054687500, 0.3662551440),
    vec2(0.3554687500, 0.6995884774),
    vec2(0.8554687500, 0.1440329218),
    vec2(0.2304687500, 0.4773662551),
    vec2(0.7304687500, 0.8106995885),
    vec2(0.4804687500, 0.2551440329),
    vec2(0.9804687500, 0.5884773663),
    vec2(0.0273437500, 0.9218106996),
    vec2(0.5273437500, 0.0699588477),
    vec2(0.2773437500, 0.4032921811),
    vec2(0.7773437500, 0.7366255144),
    vec2(0.1523437500, 0.1810699588),
    vec2(0.6523437500, 0.5144032922),
    vec2(0.4023437500, 0.8477366255),
    vec2(0.9023437500, 0.2921810700),
    vec2(0.0898437500, 0.6255144033),
    vec2(0.5898437500, 0.9588477366),
    vec2(0.3398437500, 0.1069958848),
    vec2(0.8398437500, 0.4403292181),
    vec2(0.2148437500, 0.7736625514),
    vec2(0.7148437500, 0.2181069959),
    vec2(0.4648437500, 0.5514403292),
    vec2(0.9648437500, 0.8847736626),
    vec2(0.0585937500, 0.3292181070),
    vec2(0.5585937500, 0.6625514403),
    vec2(0.3085937500, 0.9958847737),
    vec2(0.8085937500, 0.0013717421),
    vec2(0.1835937500, 0.3347050754),
    vec2(0.6835937500, 0.6680384088),
    vec2(0.4335937500, 0.1124828532),
    vec2(0.9335937500, 0.4458161866),
    vec2(0.1210937500, 0.7791495199),
    vec2(0.6210937500, 0.2235939643),
    vec2(0.3710937500, 0.5569272977),
    vec2(0.8710937500, 0.8902606310),
    vec2(0.2460937500, 0.0384087791),
    vec2(0.7460937500, 0.3717421125),
    vec2(0.4960937500, 0.7050754458),
    vec2(0.9960937500, 0.1495198903),
    vec2(0.0019531250, 0.4828532236)
);

vec2 haltonJitter(ivec2 pix, uint frame)
{
    uint hash = (uint(pix.x) * 1973u + uint(pix.y) * 9277u) & HALTON_MASK;
    uint index = (frame + hash) & HALTON_MASK;
    return HALTON_SEQUENCE[index];
}

vec2 randomJitter(ivec2 pix, uint frame)
{
    vec2 base = vec2(pix) + vec2(0.5);
    float seed = float(frame + 1u);
    float jx = gold_noise(base, seed + 1.0);
    float jy = gold_noise(base.yx, seed + 3.0);
    return vec2(jx, jy);
}

struct hitinfo_t {
    /* Index of the first index of the triangle */
    /* or: GROUND_VPTR */
    int hit_vptr;
    /* Intersection distance, barycentric coordinates */
    /* or: intersection distance, 0, texture coordinates (for the ground) */
    vec4 t;
};

struct BVHNode {
    vec4 min;
    vec4 max;
    int nbTriangles;
    int index;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

layout (std430, binding = 5) buffer BVHNodes
{
    BVHNode nodes[];
};


// Check whether there is an intersection between the ray (origin, dir) and the bounding box (bbmin, bbmax), 
// stores into tNear the nearest point of intersection on the ray.
bool intersectBoundingBox(vec4 origin, vec4 dir, vec4 bbmin, vec4 bbmax, out float tNear)
{
	// intersect with BB:
    vec4 sMin = (bbmin - origin) / dir;
    vec4 sMax = (bbmax - origin) / dir;

    vec4 tMin = min(sMin, sMax);
    vec4 tMax = max(sMin, sMax);

    tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);

	if (tNear < 0) tNear = 0; // starting point inside the BVH
    return tNear <= tFar;
}

// intersect ray (origin, dir) with triangle defined by ptr (number inside indexed face set)
// returns a boolean, plus the "t" of hitinfo structure (Intersection distance, barycentric coordinates)
bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
	// vertices from data:
    vec4 v0 = vertices[indices[ptr]];
    vec4 v1 = vertices[indices[ptr + 1]];
    vec4 v2 = vertices[indices[ptr + 2]];

    vec3 e1 = (v1 - v0).xyz;
    vec3 e2 = (v2 - v0).xyz;

    vec3 p = cross(dir.xyz, e2);
    float det = dot(e1, p);
    if (abs(det) < EPS) return false;

    // We do early exit here: as soon as we can return false, we do.
    // In my tests, it is faster than computing all coordinates, 
    // *then* checking validity with a single test. YMMV, feel free to test
    vec3 t = (origin - v0).xyz;
    dist.y = dot(t, p);
    if (dist.y < 0.0 || dist.y > det) return false;
    vec3 q = cross(t, e1);
    dist.z = dot(dir.xyz, q);
    if (dist.z < 0.0 || dist.z > det) return false;
    dist.w = det - dist.y - dist.z;
    if (dist.w < 0.0) return false;
    dist.x = dot(e2, q);
    dist /= det;
    return (dist.x > EPS);
}

bool intersectGround(vec4 origin, vec4 dir, out vec4 dist)
{
    if (abs(dir.y) < EPS)
        return false;
    float t = -(origin.y + groundDistance) / dir.y;

    if (t < MIN_DISTANCE)
        return false;

    vec4 point = origin + t * dir;
    point.y = -groundDistance;
    vec4 scaledPoint = point / radius ;
    vec2 texCoords = 0.5 * scaledPoint.xz + 0.5;

    dist = vec4(t, 0.0, texCoords);

    return true;
}

vec4 interpolateColor(hitinfo_t h)
{
	if (colors.length() > 0) {
		vec4 c0 = colors[indices[h.hit_vptr]];
		vec4 c1 = colors[indices[h.hit_vptr + 1]];
		vec4 c2 = colors[indices[h.hit_vptr + 2]];
		return (h.t.w * c0 + h.t.y * c1 + h.t.z * c2);
	} else return vec4(0.7, 0.7, 0.7, 1.0);
}

vec4 interpolateNormal(hitinfo_t h)
{
	// TODO
    if (normals.length() > 0) {
    vec3 n0 = normals[indices[h.hit_vptr]].xyz;
    vec3 n1 = normals[indices[h.hit_vptr + 1]].xyz;
    vec3 n2 = normals[indices[h.hit_vptr + 2]].xyz;
    vec3 n = normalize(h.t.w * n0 + h.t.y * n1 + h.t.z * n2);
    return vec4(n,0.0);
	} else return vec4(1,0,0,1);
    
    //return vec4(1,0,0,1);
}

// BVH-related functions:
bool isLeaf(BVHNode node)
{
    return node.nbTriangles != 0;
}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir, inout hitinfo_t h)
{
    bool hit = false;

    for (int i = 0; i < node.nbTriangles; ++i) {
        int vptr = 3 * (node.index + i);
        vec4 dist;
        if (intersectTriangle(origin, dir, vptr, dist) && dist.x < h.t.x) {
            hit = true;
            h.hit_vptr = vptr;
            h.t = dist;
        }
    }

    return hit;
}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir)
{
    for (int i = 0; i < node.nbTriangles; ++i) {
        int vptr = 3 * (node.index + i);
        vec4 dist;
        if (intersectTriangle(origin, dir, vptr, dist))
            return true;
    }

    return false;
}

#define MAX_STACK_SIZE 64

#define push(stack, size, value) stack[size++] = value
#define pop(stack, size) stack[--size]

bool intersectBVH(vec4 origin, vec4 dir, inout hitinfo_t h)
{
    int rootIndex = 0;
    BVHNode rootNode = nodes[rootIndex];
    float tNear;

    if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
        return false;

    struct StackElement {
        int index;
        float t;
    } stack[MAX_STACK_SIZE];
    int size = 0;

    push(stack, size, StackElement(rootIndex, 0.0));

    bool hit = false;


    while (size != 0) {
        StackElement current = pop(stack, size);
        if (h.t.x < current.t)
            continue;

        BVHNode currentNode = nodes[current.index];
        if (isLeaf(currentNode)) {
            hit = intersectBVHLeaf(currentNode, origin, dir, h) || hit;
        } else {
            StackElement left = StackElement(current.index + 1, 0.0);
            BVHNode leftNode = nodes[left.index];
            bool hitLeft = intersectBoundingBox(origin, dir, leftNode.min, leftNode.max, left.t);

            StackElement right = StackElement(currentNode.index, 0.0);
            BVHNode rightNode = nodes[right.index];
            bool hitRight = intersectBoundingBox(origin, dir, rightNode.min, rightNode.max, right.t);

            if (hitLeft && hitRight) {
                if (left.t < right.t) {
                    push(stack, size, right);
                    push(stack, size, left);
                } else {
                    push(stack, size, left);
                    push(stack, size, right);
                }
            } else if (hitLeft) {
                push(stack, size, left);
            } else if (hitRight) {
                push(stack, size, right);
            }
        }
    }


    return hit;
}

bool intersectBVH(vec4 origin, vec4 dir)
{
    int rootIndex = 0;
    BVHNode rootNode = nodes[rootIndex];
    float tNear;

    if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
        return false;

    int stack[MAX_STACK_SIZE];
    int size = 0;

    push(stack, size, rootIndex);

    while (size != 0) {
        int current = pop(stack, size);
        BVHNode currentNode = nodes[current];
        if (isLeaf(currentNode)) {
            if (intersectBVHLeaf(currentNode, origin, dir))
                return true;
        } else {
            int left = current + 1;
            BVHNode leftNode = nodes[left];
            bool hitLeft = intersectBoundingBox(origin, dir, leftNode.min, leftNode.max, tNear);

            int right = currentNode.index;
            BVHNode rightNode = nodes[right];
            bool hitRight = intersectBoundingBox(origin, dir, rightNode.min, rightNode.max, tNear);

            if (hitLeft && hitRight) {
                push(stack, size, right);
                push(stack, size, left);
            } else if (hitLeft) {
                push(stack, size, left);
            } else if (hitRight) {
                push(stack, size, right);
            }
        }
    }

    return false;
}
// End BVH-related functions

// Compute the first intersection along the ray (origin, dir). 
// returns the nearest intersection in h
bool firstIntersection(vec4 origin, vec4 dir, out hitinfo_t h)
{
    h.t.x = radius * MAX_SCENE_BOUNDS;

    bool hit = intersectBVH(origin, dir, h);

    vec4 dist;
    if (intersectGround(origin, dir, dist) && dist.x < h.t.x) {
        hit = true;
        h.hit_vptr = GROUND_VPTR;
        h.t = dist;
    }

	return hit;
}

// checks whether there is any intersection along the ray (origin, dir)
// Does not compute the nearest intersection, ends the loop as soon as an intersection is found.
bool isIntersected(vec4 origin, vec4 dir)
{
    vec4 dist;
    return intersectGround(origin, dir, dist) || intersectBVH(origin, dir);
}

// Local illumination related functions. TODO


float fresnel(float cos_d, float eta){
    float cosClamped = clamp(cos_d, -1.0, 1.0);
    float sin2 = max(0.0, 1.0 - cosClamped * cosClamped);
    float eta2 = eta * eta;
    float radicand = eta2 - sin2;

    if (radicand <= 0.0)
        return 1.0;

    float ci = sqrt(radicand);
    float denomS = max(abs(cosClamped + ci), EPS);
    float denomP = max(abs(eta2 * cosClamped + ci), EPS);
    float Fs = pow((cosClamped - ci) / denomS, 2.0);
    float Fp = pow((eta2 * cosClamped - ci) / denomP, 2.0);

    return 0.5 * (Fs + Fp);
}

float ggx_D(float cos_theta, float alpha){
    float chi = step(0.0, cos_theta); // χ_[0,π/2](θh)
    if (chi == 0.0)
        return 0.0;

    float a2 = alpha * alpha;
    float cos2 = max(cos_theta * cos_theta, EPS);
    float tan2 = (1.0 - cos2) / cos2;
    float denom = cos2 * cos2 * pow(a2 + tan2, 2.0);
    return chi * a2 * M_1_PI / max(denom, EPS);
}

float ggx_G1(float cos_theta, float alpha){
    if (cos_theta <= 0.0)
        return 0.0;

    float a2 = alpha * alpha;
    float cos2 = max(cos_theta * cos_theta, EPS);
    float tan2 = max((1.0 - cos2) / cos2, 0.0);
    float denom = 1.0 + sqrt(1.0 + a2 * tan2);
    return 2.0 / max(denom, EPS);
}

vec4 directIllumination(vec4 color, vec4 p, vec4 n, vec4 v)
{
	// Goal: compute direct illumination at point p, from the light source at lightPosition.
	// color: local material color, RGBA
	// p: coordinates of intersection point, xyzw
	// n: normal at intersection point, xyzw
	// v: incoming viewing direction. Points towards the eye.

    vec3 N = normalize(n.xyz);
    vec3 toLight = lightPosition - p.xyz;
    vec3 L = normalize(toLight);           // Light direction
    vec3 V = normalize(v.xyz);             // View direction (towards the eye)
    vec3 C = color.rgb;

    // Ambient term is always present
    vec3 Ca = Ka * C * lightIntensity;

    float NL = dot(N, L);
    if (NL <= 0.0) {
        return vec4(Ca, 1.0);
    }

    // Hard shadow visibility test based on the TP4 lecture slides on shadows
    float lightDistance = length(toLight);
    vec4 shadowOrigin = vec4(p.xyz + N * SHADOW_BIAS, 1.0);
    vec4 shadowDir = vec4(L, 0.0);
    hitinfo_t hs;
    bool occluded = false;
    if (firstIntersection(shadowOrigin, shadowDir, hs) && hs.t.x < lightDistance - SHADOW_BIAS) {
        occluded = true;
    }

    if (occluded) {
        return vec4(Ca, 1.0);
    }

    // Diffuse Lighting: Cd = Kd * C * max(n ⋅ L, 0.0) * I  (Lambert cosine law)
    vec3 Cd = Kd * C * NL * lightIntensity;

    // Specular lighting (Blinn-Phong or Cook-Torrance depending on UI toggle)
    vec3 H = normalize(L + V);
    float cos_d = max(dot(H, L), 0.0);
    float F = fresnel(cos_d, eta);

    vec3 Cs;
    if (blinnPhong) {
        float dotNH = pow(max(dot(N, H), 0.0), shininess);
        Cs = F * C * dotNH * lightIntensity;
    } else {
        float cos_i = NL;
        float cos_o = max(dot(N, V), 0.0);
        float cos_h = max(dot(N, H), 0.0);
        float alpha = 0.2 * pow(0.005, shininess / 200);
        float D = ggx_D(cos_h, alpha);
        float G = ggx_G1(cos_i, alpha) * ggx_G1(cos_o, alpha);
        float denom = max(4.0 * cos_i * cos_o, EPS);
        float spec = (F * D * G) / denom;
        Cs = vec3(spec * lightIntensity);
    }

    return vec4(Ca + Cd + Cs, 1.0);
}

const int MAX_TRACE = 3;

void getLocal(vec4 origin, vec4 dir, hitinfo_t h, out vec4 color, out vec4 p, out vec4 n)
{
    p = origin + h.t.x * dir;
    if (h.hit_vptr == GROUND_VPTR) {
        color = texture(colorTexture, h.t.pq);
        p.y = -groundDistance;
        n = vec4(0.0, 1.0, 0.0, 0.0);
    } else {
        color = interpolateColor(h);
        n = interpolateNormal(h);
    }
    p.w = 1.0;
}


struct trace_state_t
{
    vec4 origin;  // start of ray
    vec4 dir;     // direction
    vec4 color;   // color after multiple bounces
    vec4 localColor;   // color of the material (after interpolation)
    hitinfo_t h;  // what the ray hits (triangle Id, u, v, lambda)
    vec4 hit;     // point the ray hits 
    vec4 Ld;      // direction to light at destination
    vec4 N;       // normal at destination
};

vec4 trace(vec4 origin, vec4 dir)
{
    // These variables are for TP2
    trace_state_t stack[MAX_TRACE + 1];
    bool fallback[MAX_TRACE + 1];
    int sp = 0;

	// These are for TP1:
    vec4 currentOrigin = origin;
    vec4 currentDir = normalize(dir);

    while (sp <= MAX_TRACE) {
        hitinfo_t h;
        if (!firstIntersection(currentOrigin, currentDir, h)) {
            break;
        }

        trace_state_t state;
        state.origin = currentOrigin;
        state.dir = currentDir;
        state.h = h;
        getLocal(currentOrigin, currentDir, h, state.localColor, state.hit, state.N);
        state.color = vec4(0.0);
        state.Ld = vec4(0.0);

        vec3 normal = normalize(state.N.xyz);
        vec3 incident = normalize(currentDir.xyz);
        if (dot(normal, incident) > 0.0) {
            normal = -normal;
            state.N = vec4(normal, 0.0);
        } else {
            state.N = vec4(normal, 0.0);
        }

        vec3 nextDir = normalize(reflect(incident, normal));
        bool transmitted = false;

        fallback[sp] = transmitted;
        stack[sp] = state;
        ++sp;

        vec3 offsetPos = state.hit.xyz + nextDir * REFLECTION_BIAS;
        currentOrigin = vec4(offsetPos, 1.0);
        currentDir = vec4(nextDir, 0.0);
    }

    if (sp == 0) {
        return vec4(0.0, 0.0, 0.0, 1.0);
    }

    vec3 accumulated = vec3(0.0);

    for (int i = sp - 1; i >= 0; --i) {
        trace_state_t state = stack[i];
        vec4 direct = directIllumination(state.localColor, state.hit, state.N, -state.dir);
        vec3 result = direct.rgb;

        if (length(accumulated) > 0.0) {
            vec3 normal = normalize(state.N.xyz);
            vec3 incoming = normalize(state.dir.xyz);
            float cosInc = clamp(dot(normal, -incoming), -1.0, 1.0);
            float F = fresnel(cosInc, eta);
            float weight = fallback[i] ? (1.0 - F) : F;
            result += weight * state.localColor.rgb * accumulated;
        }

        accumulated = result;
    }

    return vec4(accumulated, 1.0);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }

    vec4 accumData = imageLoad(framebuffer, pix);
    vec4 momentData = imageLoad(momentsBuffer, pix);
    float sampleCount = accumData.a;
    vec3 meanColor = accumData.rgb;
    vec3 m2 = momentData.rgb;
    bool converged = momentData.a > 0.5;

    vec2 jitter = useHaltonSequence ? haltonJitter(pix, frameIndex) : randomJitter(pix, frameIndex);
    vec2 pos = (vec2(pix) + jitter) / (vec2(size) - vec2(0.5, 0.5));
    pos = 2.0 * pos - vec2(1.0, 1.0);

    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0.0;
    worldPos = normalize(worldPos);
    vec4 dir = normalize(mat_inverse * worldPos);
    vec4 eye = mat_inverse * vec4(0.0, 0.0, 0.0, 1.0);

    if (!converged) {
        vec3 sampleColor = trace(eye, dir).rgb;
        float newCount = sampleCount + 1.0;
        vec3 delta = sampleColor - meanColor;
        vec3 updatedMean = meanColor + delta / newCount;
        vec3 delta2 = sampleColor - updatedMean;
        vec3 updatedM2 = m2 + delta * delta2;

        if (newCount >= MIN_SAMPLE_COUNT) {
            vec3 variance = updatedM2 / newCount;
            vec3 sigma = sqrt(max(variance, vec3(0.0)));
            float meanLuma = dot(abs(updatedMean), LUMA_WEIGHTS);
            float sigmaLuma = dot(sigma, LUMA_WEIGHTS);
            float threshold = max(MIN_STD_THRESHOLD, CONVERGENCE_RATIO * meanLuma);
            if (sigmaLuma <= threshold) {
                converged = true;
            }
        }

        meanColor = updatedMean;
        m2 = updatedM2;
        sampleCount = newCount;
    }

    imageStore(framebuffer, pix, vec4(meanColor, sampleCount));
    imageStore(momentsBuffer, pix, vec4(m2, converged ? 1.0 : 0.0));
}
